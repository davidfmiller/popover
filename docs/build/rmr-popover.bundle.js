/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/rmr-util/index.js":
/*!****************************************!*\
  !*** ./node_modules/rmr-util/index.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/* global require, module, console, Promise, HTMLElement */\n\n(function () {\n\n  'use strict';\n\n  /**\n   * rmr-util\n   *\n   * JS for your browser\n   *\n   *\n   *\n   */\n\n  var\n\n  /**\n   *\n   *\n   */\n  Base64 = {\n    _keyStr: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\",\n    encode: function encode(e) {\n      var t = \"\";\n      var n = void 0,\n          r = void 0,\n          i = void 0,\n          s = void 0,\n          o = void 0,\n          u = void 0,\n          a = void 0;\n      var f = 0;\n      e = Base64._utf8_encode(e);\n      while (f < e.length) {\n        n = e.charCodeAt(f++);\n        r = e.charCodeAt(f++);\n        i = e.charCodeAt(f++);\n        s = n >> 2;\n        o = (n & 3) << 4 | r >> 4;\n        u = (r & 15) << 2 | i >> 6;\n        a = i & 63;\n        if (isNaN(r)) {\n          u = a = 64;\n        } else if (isNaN(i)) {\n          a = 64;\n        }\n        t = t + this._keyStr.charAt(s) + this._keyStr.charAt(o) + this._keyStr.charAt(u) + this._keyStr.charAt(a);\n      }\n      return t;\n    },\n\n    decode: function decode(e) {\n\n      var t = \"\";\n      var n = void 0,\n          r = void 0,\n          i = void 0,\n          s = void 0,\n          o = void 0,\n          u = void 0,\n          a = void 0;\n      var f = 0;\n\n      e = e.replace(/[^A-Za-z0-9\\+\\/\\=]/g, \"\");\n\n      while (f < e.length) {\n        s = this._keyStr.indexOf(e.charAt(f++));\n        o = this._keyStr.indexOf(e.charAt(f++));\n        u = this._keyStr.indexOf(e.charAt(f++));\n        a = this._keyStr.indexOf(e.charAt(f++));\n        n = s << 2 | o >> 4;\n        r = (o & 15) << 4 | u >> 2;\n        i = (u & 3) << 6 | a;\n        t = t + String.fromCharCode(n);\n        if (u !== 64) {\n          t = t + String.fromCharCode(r);\n        }\n        if (a !== 64) {\n          t = t + String.fromCharCode(i);\n        }\n      }\n      t = Base64._utf8_decode(t);\n      return t;\n    },\n    _utf8_encode: function _utf8_encode(e) {\n      e = e.replace(/\\r\\n/g, \"\\n\");\n      var t = \"\",\n          n = 0;\n      for (n = 0; n < e.length; n++) {\n        var r = e.charCodeAt(n);\n        if (r < 128) {\n          t += String.fromCharCode(r);\n        } else if (r > 127 && r < 2048) {\n          t += String.fromCharCode(r >> 6 | 192);\n          t += String.fromCharCode(r & 63 | 128);\n        } else {\n          t += String.fromCharCode(r >> 12 | 224);\n          t += String.fromCharCode(r >> 6 & 63 | 128);\n          t += String.fromCharCode(r & 63 | 128);\n        }\n      }\n      return t;\n    },\n\n    _utf8_decode: function _utf8_decode(e) {\n      var t = \"\",\n          n = 0,\n          r = 0,\n          c2 = 0,\n          c3 = 0;\n\n      while (n < e.length) {\n        r = e.charCodeAt(n);\n        if (r < 128) {\n          t += String.fromCharCode(r);\n          n++;\n        } else if (r > 191 && r < 224) {\n          c2 = e.charCodeAt(n + 1);\n          t += String.fromCharCode((r & 31) << 6 | c2 & 63);\n          n += 2;\n        } else {\n          c2 = e.charCodeAt(n + 1);\n          c3 = e.charCodeAt(n + 2);\n          t += String.fromCharCode((r & 15) << 12 | (c2 & 63) << 6 | c3 & 63);\n          n += 3;\n        }\n      }\n      return t;\n    }\n  },\n\n\n  /**\n   * Retrieve an element via query selector, or\n   *\n   * @param {Mixed} arg the element to retrieve, or null if no such element exists\n   * @return {Element} element corresponding to the selector (or null if none exists)\n   */\n  getElement = function getElement(arg) {\n    if (typeof arg === 'string') {\n      return document.querySelector(arg);\n    } else if (arg instanceof HTMLElement) {\n      return arg;\n    }\n\n    return null;\n  },\n\n\n  /**\n   * Determine if a string is a valid internet URL\n   *\n   * @param {String} str - the string to be tested\n   * @return {Bool} - `true` of `false`\n   */\n  isURL = function isURL(str) {\n    // ???\n    return (/^(?:(?:(?:https?|ftp):)?\\/\\/)(?:\\S+(?::\\S*)?@)?(?:(?!(?:10|127)(?:\\.\\d{1,3}){3})(?!(?:169\\.254|192\\.168)(?:\\.\\d{1,3}){2})(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,})))(?::\\d{2,5})?(?:[/?#]\\S*)?$/i.test(str)\n    );\n  },\n\n\n  /**\n    Format a latitude coordinate value into a human-friendly string\n     @param {Float} lat  value to be formatted\n    @return {String} formatted latitude string\n   */\n  formatLatitude = function formatLatitude(lat) {\n\n    var value = parseFloat(lat);\n\n    var dir = value < 0 ? 'S' : 'N';\n\n    var degrees = 0,\n        minutes = 0,\n        seconds = 0;\n\n    degrees = parseInt(value);\n    value = (value - degrees) * 60;\n\n    minutes = parseInt(value);\n    seconds = (value - minutes) * 60;\n\n    if (seconds < 0) {\n      seconds *= -1;\n    }\n\n    return Math.abs(degrees) + 'º' + Math.abs(minutes) + '’' + seconds.toFixed(2) + '”' + dir;\n  },\n\n\n  /**\n    Format a longitude coordinate value into a human-friendly string\n     @param {Float} lon  value to be formatted\n    @return {String} formatted longitude string\n   */\n  formatLongitude = function formatLongitude(lon) {\n\n    var value = parseFloat(lon);\n\n    var dir = value < 0 ? 'W' : 'E';\n\n    var degrees = 0,\n        minutes = 0,\n        seconds = 0;\n\n    degrees = parseInt(value);\n    value = (value - degrees) * 60;\n\n    minutes = parseInt(value);\n    seconds = (value - minutes) * 60;\n\n    return Math.abs(degrees) + 'º' + Math.abs(minutes) + '’' + Math.abs(seconds.toFixed(2)) + '”' + dir;\n  },\n\n\n  /**\n   * Determine if a node matches a provided selector\n   *\n   * @param {HTMLElement} node  the element to be tested\n   * @param {String} selector the selector string to test\n   * @return {Bool} `true` or `false`\n   */\n  selectorMatches = function selectorMatches(node, selector) {\n\n    var p = Element.prototype,\n        f = p.matches || p.webkitMatchesSelector || p.mozMatchesSelector || p.msMatchesSelector || function matches() {\n      return [].indexOf.call(document.querySelectorAll(selector), this) !== -1;\n    };\n    try {\n      return f.call(node, selector);\n    } catch (e) {\n      return false;\n    }\n  },\n\n\n  /**\n   * Determine if we're in a touch-based browser (phone/tablet)\n   *\n   * @return {Bool} `true` or `false`\n   */\n  isTouch = function isTouch() {\n\n    if (typeof window === 'undefined' || typeof navigator === 'undefined') {\n      return false;\n    }\n    return typeof window.orientation !== 'undefined';\n  },\n\n\n  /**\n   * Determine if we're in Safari\n   *\n   * @return {Bool} `true` or `false`\n   */\n  isSafari = function isSafari() {\n\n    if (typeof window === 'undefined' || typeof navigator === 'undefined') {\n      return false;\n    }\n    return (/^((?!chrome|android).)*safari/i.test(navigator.userAgent)\n    );\n  },\n\n\n  /**\n   * Determine if we're in Firefox\n   *\n   * @return {Bool} `true` or `false`\n   */\n  isFirefox = function isFirefox() {\n\n    if (typeof window === 'undefined' || typeof navigator === 'undefined') {\n      return false;\n    }\n    return navigator.userAgent.indexOf(\"Firefox\") > 0;\n  },\n\n\n  /**\n   * Is the browser capable of opening new windows/tabs with \"data:\" protocol\n   *\n   * @see https://groups.google.com/a/chromium.org/forum/#!topic/blink-dev/GbVcuwg_QjM%5B1-25%5D\n   * @return {Bool} `true` if the browser opens `data:` URLs; `false` if not\n   */\n  opensData = function opensData() {\n    return isFirefox() || isSafari();\n  },\n\n\n  /**\n   * Retrieve an object containing browser/screen coordinates for a DOM element\n   *\n   * @param {Element} node the element whose coordinates should be retrieved\n   * @return {Object} An object containing { top : xx, left : xx, bottom: xx, right: xx, width: xx, height: xx }\n   */\n  getRect = function getRect(node) {\n\n    node = getElement(node);\n    if (!node) {\n      return { top: 0, left: 0, right: 0, width: 0, height: 0 };\n    }\n\n    var rect = node.getBoundingClientRect(),\n        ret = { top: rect.top, left: rect.left, bottom: rect.bottom, right: rect.right }; // create a new object that is not read-only\n\n    ret.top += window.pageYOffset;\n    ret.left += window.pageXOffset;\n\n    ret.bottom += window.pageYOffset;\n    ret.right += window.pageYOffset;\n\n    ret.width = rect.right - rect.left;\n    ret.height = rect.bottom - rect.top;\n\n    return ret;\n  },\n\n\n  /**\n   * Scroll to an element\n   *\n   * @param {Mixed} y - vertical offset to scroll to, or selector/node references for the Element to scroll to\n   * @param {Integer} duration - # of milliseconds animation should run\n   */\n  scrollTo = function scrollTo(y, duration) {\n\n    if (arguments.length === 1) {\n      duration = 200;\n    }\n\n    if (typeof y === 'string' || y instanceof Element) {\n      y = getRect(y).top;\n    }\n\n    var startingY = window.pageYOffset,\n        diff = y - startingY;\n\n    var start = void 0;\n\n    // Bootstrap our animation - it will get called right before next frame shall be rendered.\n    window.requestAnimationFrame(function step(timestamp) {\n\n      if (!start) {\n        start = timestamp;\n      }\n\n      var time = timestamp - start,\n          percent = Math.min(time / duration, 1);\n\n      window.scrollTo(0, startingY + diff * percent);\n\n      // Proceed with animation as long as we wanted it to.\n      if (time < duration) {\n        window.requestAnimationFrame(step);\n      }\n    });\n  },\n\n\n  /*\n   * Generate a unique string suitable for id attributes\n   *\n   * @param basename (String)\n   * @return string\n   */\n  guid = function guid(basename) {\n    return (basename ? basename : 'rmr-guid-') + parseInt(Math.random() * 100, 10) + '-' + parseInt(Math.random() * 1000, 10);\n  },\n\n\n  /*\n   * Merge two objects into one, values in b take precedence over values in a\n   *\n   * @param a {Object}\n   * @param b {Object}\n    * @return Object\n   */\n  objectMerge = function objectMerge(a, b) {\n    var o = {};\n    var i = null;\n    for (i in a) {\n      if (a.hasOwnProperty(i)) {\n        o[i] = a[i];\n      }\n    }\n    if (!b) {\n      return o;\n    }\n    for (i in b) {\n      if (b.hasOwnProperty(i)) {\n        o[i] = b[i];\n      }\n    }\n    return o;\n  },\n\n\n  /**\n   * Convert an array-like thing (ex: NodeList or arguments object) into a proper array, or convert a scalar into a single-element array\n   *\n   * @param {Mixed} list an array-like thing or a scalar\n   * @return {Array} the param as an array\n   */\n  arr = function arr(list) {\n\n    var ret = [];\n    var i = 0;\n\n    if (list instanceof Array) {\n      return list;\n    }\n\n    if (typeof list.length !== 'number') {\n      return [list];\n    }\n\n    for (i = 0; i < list.length; i++) {\n      if (list.hasOwnProperty(i)) {\n        ret.push(list[i]);\n      }\n    }\n\n    return ret;\n  },\n\n\n  /**\n   * Remove an object from an array\n   *\n   * @param {Array} array containing object to be removed\n   * @param {Any} item to be removed\n   * @return {Array} array for chaining\n   */\n  arrayRemove = function arrayRemove(array, item) {\n    return arr(array).filter(function (e) {\n      return e !== item;\n    });\n  },\n\n\n  /**\n   * Return the index of an item in an array\n   *\n   * @param {Array} list that should be searched\n   * @param {Function} func comparator function that takes on argument\n   * @return {Integer} index of the item in the array, or -1 if it doesn't exist\n   */\n  arrayFind = function arrayFind(list, func) {\n\n    var array = arr(list);\n\n    if (typeof func !== 'function') {\n\n      var target = func,\n          lookup = function lookup(param) {\n\n        if ((typeof param === \"undefined\" ? \"undefined\" : _typeof(param)) === 'object' && param.hasOwnProperty('id')) {\n          if ((typeof target === \"undefined\" ? \"undefined\" : _typeof(target)) === 'object' && target.hasOwnProperty('id')) {\n            return param.id === target.id;\n          }\n          return param.id === target;\n        }\n\n        return param === target;\n      };\n      func = lookup;\n    }\n    for (var i in array) {\n      if (!array.hasOwnProperty(i)) {\n        continue;\n      }\n\n      if (array[i] === func || func(array[i])) {\n        return parseInt(i, 10);\n        break;\n      }\n    }\n    return -1;\n  },\n\n\n  /**\n   * Shift the objects within an array so that a given item is first\n   *\n   * @param {Array} array containing object to be removed\n   * @param {Any} item to be made the first\n   * @return {Array} array for chaining\n   */\n  arrayReorder = function arrayReorder(array, item) {\n\n    var list = arr(array),\n        reordered = [];\n\n    var index = arrayFind(list, item);\n    if (index === -1) {\n      return list;\n    }\n\n    reordered.push(list[index]);\n\n    for (var i = index + 1; i < list.length; i++) {\n      reordered.push(array[i]);\n    }\n\n    for (var _i = 0; _i < index; _i++) {\n      reordered.push(array[_i]);\n    }\n\n    return reordered;\n  },\n\n\n  /**\n   * Remove all children from a node (optionally matching a selector)\n   *\n   * @param {Mixed} arg - node or selector whose children should be removed\n   * @param {String,optional} selector - query selector that children must match in order to be removed\n   * @return {HTMLElement} - for chaining\n   */\n  pruneElement = function pruneElement(arg, selector) {\n\n    var node = getElement(arg);\n    if (!node) {\n      return null;\n    }\n    if (selector) {\n      var n = arr(arg.querySelectorAll(selector));\n      for (var i = 0; i < n.length; i++) {\n        removeNode(n[i]);\n      }\n    } else {\n      while (node.firstChild) {\n        node.removeChild(node.firstChild);\n      }\n    }\n\n    return node;\n  },\n\n\n  /**\n   * Retrieve an element via query selector\n   *\n   * @param {Mixed} arg selector, or an array of elements to attach\n   * @param {Mixed,optional} scope the parent node\n   * @return {[Element]} array of elements\n   */\n  getElements = function getElements(arg, scope) {\n\n    if (!scope) {\n      scope = document;\n    } else {\n      scope = getElement(scope);\n    }\n\n    if (typeof arg === 'string') {\n      return arr(scope.querySelectorAll(arg));\n    }\n\n    return arr(arg);\n  },\n\n\n  /*\n   * Create an element with a set of attributes/values\n   *\n   * @param type (String)\n   * @param attrs {Object}\n   *\n   * @return HTMLElement\n   */\n  makeElement = function makeElement(type, attrs) {\n\n    var n = document.createElement(type);\n\n    for (var i in attrs) {\n      if (attrs.hasOwnProperty(i) && attrs[i]) {\n        n.setAttribute(i, attrs[i]);\n      }\n    }\n    return n;\n  },\n\n\n  /**\n   * Make loader\n   *\n   * @return {String} SVG element\n   */\n  loader = function loader() {\n\n    /*\n        const svg = makeElement('svg', {\n          version: '1.1',\n          class: 'rmr-loader',\n          xmlns: 'http://www.w3.org/2000/svg',\n          'xmlns:xlink': 'http://www.w3.org/1999/xlink',\n          x: '0px',\n          y: '0px',\n          width: '40px',\n          height: '40px',\n          viewBox: '0 0 40 40',\n          'enable-background': 'new 0 0 40 40',\n          'xml:space': 'preserve'\n        });\n    \n        svg.innerHTML =\n        '<path opacity=\"0.2\" fill=\"#000\" d=\"M20.201,5.169c-8.254,0-14.946,6.692-14.946,14.946c0,8.255,6.692,14.946,14.946,14.946 s14.946-6.691,14.946-14.946C35.146,11.861,28.455,5.169,20.201,5.169z M20.201,31.749c-6.425,0-11.634-5.208-11.634-11.634 c0-6.425,5.209-11.634,11.634-11.634c6.425,0,11.633,5.209,11.633,11.634C31.834,26.541,26.626,31.749,20.201,31.749z\"></path>' +\n        '<path fill=\"#000\" d=\"M26.013,10.047l1.654-2.866c-2.198-1.272-4.743-2.012-7.466-2.012h0v3.312h0 C22.32,8.481,24.301,9.057,26.013,10.047z\">' +\n        '<animateTransform attributeType=\"xml\" attributeName=\"transform\" type=\"rotate\" from=\"0 20 20\" to=\"360 20 20\" dur=\"0.8s\" repeatCount=\"indefinite\"></animateTransform>' +\n        '</path>';\n    */\n\n    return '<svg version=\"1.1\" class=\"rmr-loader\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" width=\"40px\" height=\"40px\" viewBox=\"0 0 40 40\" enable-background=\"new 0 0 40 40\" xml:space=\"preserve\">' + '<path opacity=\"0.2\" fill=\"#000\" d=\"M20.201,5.169c-8.254,0-14.946,6.692-14.946,14.946c0,8.255,6.692,14.946,14.946,14.946 s14.946-6.691,14.946-14.946C35.146,11.861,28.455,5.169,20.201,5.169z M20.201,31.749c-6.425,0-11.634-5.208-11.634-11.634 c0-6.425,5.209-11.634,11.634-11.634c6.425,0,11.633,5.209,11.633,11.634C31.834,26.541,26.626,31.749,20.201,31.749z\"></path>' + '<path fill=\"#000\" d=\"M26.013,10.047l1.654-2.866c-2.198-1.272-4.743-2.012-7.466-2.012h0v3.312h0 C22.32,8.481,24.301,9.057,26.013,10.047z\">' + '<animateTransform attributeType=\"xml\" attributeName=\"transform\" type=\"rotate\" from=\"0 20 20\" to=\"360 20 20\" dur=\"0.8s\" repeatCount=\"indefinite\"></animateTransform>' + '</path>' + '</svg>';\n\n    //    return svg;\n  },\n\n\n  /**\n   * Localize a string\n   *\n   * {\n   *   'en' : {\n   *      'key' : 'neighbor'\n   *    },\n   *    'en-ca' : {\n   *      'key' : 'neighbour'\n   *    }\n   *  }\n   *\n   * @param {Object} lookup dictionary\n   * @param {String} key the to localize\n   * @return {String} string\n   */\n  localize = function localize(lookup, key) {\n\n    if (typeof navigator === 'undefined') {\n      return key;\n    }\n\n    var i = void 0,\n        lang = void 0;\n\n    for (i in navigator.languages) {\n      if (!navigator.languages.hasOwnProperty(i)) {\n        continue;\n      }\n      lang = navigator.languages[i].toLowerCase();\n      if (lookup.hasOwnProperty(lang) && lookup[lang].hasOwnProperty(key)) {\n        return lookup[lang][key];\n      }\n    }\n\n    for (i in navigator.languages) {\n      if (!navigator.languages.hasOwnProperty(i)) {\n        continue;\n      }\n      lang = navigator.languages[i].split('-')[0].toLowerCase();\n      if (lookup.hasOwnProperty(lang) && lookup[lang].hasOwnProperty(key)) {\n        return lookup[lang][key];\n      }\n    }\n\n    //    console.warn('No localization for ' + key);\n    return key;\n  },\n\n\n  /**\n   * Apply styles to a node\n   *\n   * @param {HTMLElement} node that should have styles applied\n   * @param {Object} styles key/value pairs for styles and values\n   * @return {Element} node\n   */\n  setStyles = function setStyles(node, styles) {\n\n    node = getElement(node);\n    if (!node) {\n      return false;\n    }\n\n    for (var i in styles) {\n      if (styles.hasOwnProperty(i) && styles[i]) {\n        node.style[i] = styles[i];\n      }\n    }\n\n    return node;\n  },\n\n\n  /**\n   * Build a query string from an object\n   *\n   * @param {Object} obj the object to be passed via URL\n   * @return {String} str query string corresponding to the object\n   */\n  queryString = function queryString(obj) {\n\n    if (Object.keys(obj).length === 0) {\n      return '';\n    }\n\n    return Object.keys(obj).reduce(function (a, k) {\n      a.push(k + '=' + encodeURIComponent(obj[k]));\n      return a;\n    }, []).join('&');\n  },\n\n\n  /**\n   * Return an array of all keys in an object (polyfill for Object.keys)\n   *\n   * @param {Object} obj object whose keys should be retrieved\n   * @return {Array} key list\n   */\n  objectKeys = function objectKeys(obj) {\n\n    if (typeof Object !== \"undefined\" && typeof Object.keys !== \"undefined\") {\n      return Object.keys(obj);\n    }\n\n    var a = [];\n    for (var i in obj) {\n      if (obj.hasOwnProperty(i)) {\n        a.push(i);\n      }\n    }\n\n    return a;\n  },\n\n\n  /**\n   * Retrieve (potentially nested) value from object\n   *\n   * @param {Object} object - target object to be inspected\n   * @param {String} path - nested paths\n   * @param {Mixed} fallback - value to return if path not found (default to `null`)\n   * @return {Mixed} - value found at path, or `null` if no such path exists\n   */\n  objectGet = function objectGet(object, path, fallback) {\n\n    var bits = path.split('.');\n    var target = object;\n\n    for (var i = 0; i < bits.length; i++) {\n      if (!target.hasOwnProperty(bits[i])) {\n        return fallback ? fallback : null;\n      }\n      target = target[bits[i]];\n    }\n\n    return target;\n  },\n      objectHas = function objectHas(obj, key) {\n    return Object.prototype.hasOwnProperty.call(obj, key);\n  },\n\n\n  /**\n   * Generate an object containing keys/values corresponding to form elements\n   *\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/FormData/Using_FormData_Objects\n   * @param {Element} form element\n   * @return {Object} the key/value pairs for the form\n   */\n  objectFromForm = function objectFromForm(form) {\n\n    form = getElement(form);\n    if (!form) {\n      return {};\n    }\n\n    if (typeof FormData !== 'undefined') {\n      //      const f = new FormData(form);\n      //      console.log(f);\n      //      return f;\n    }\n\n    var inputs = form.querySelectorAll('select,input,textarea'),\n        params = {};\n\n    for (var i in inputs) {\n      if (!inputs.hasOwnProperty(i)) {\n        continue;\n      }\n      var name = inputs[i].getAttribute('name'),\n          type = inputs[i].type ? inputs[i].type : 'text';\n\n      if (inputs[i].hasAttribute('disabled')) {\n        continue;\n      }\n\n      if (type === 'radio' || type === 'checkbox') {\n        if (inputs[i].checked) {\n          params[name] = inputs[i].value;\n        }\n      } else {\n        params[name] = inputs[i].value;\n      }\n    }\n\n    return params;\n  },\n\n\n  /**\n   * Add event listener to >= 1 node\n   *\n   * @param {String} selector to match nodes\n   * @param {String} eventName the event which should be listened for\n   * @param {Function} func the method to invoke when eventName occurs\n   */\n  addListener = function addListener(selector, eventName, func) {\n    var nodes = getElements(selector);\n    var i = 0;\n\n    for (i in nodes) {\n      if (nodes.hasOwnProperty(i)) {\n        nodes[i].addEventListener(eventName, func);\n      }\n    }\n  },\n\n\n  /**\n   * Get a node's ancestor\n   *\n   * @param {Element} node starting point of search\n   * @param {String} ancestor the selector for the ancestor we're looking for\n   * @param {Bool} includeSelf optionally include starting point in search\n   * @return {Element} or `null` if no such ancestor exists\n   */\n  ancestor = function ancestor(node, _ancestor, includeSelf) {\n\n    node = getElement(node);\n    if (!node) {\n      return null;\n    }\n\n    if (includeSelf && selectorMatches(node, _ancestor)) {\n      return node;\n    }\n\n    var parent = node;\n\n    if (!parent.parentNode) {\n      return null;\n    }\n\n    while ((parent = parent.parentNode) !== null) {\n\n      if (!parent instanceof Element) {\n        return null;\n      }\n\n      if (selectorMatches(parent, _ancestor)) {\n        return parent;\n      }\n    }\n\n    return null;\n  },\n\n\n  /**\n   * Remove a DOM node from the document\n   *\n   * @param {Element} node the node to be removed\n   * @return {Bool} `true` if removed'; `false` if the node doesn't exist\n   */\n  removeNode = function removeNode(node) {\n\n    node = getElement(node);\n    if (!node) {\n      return false;\n    }\n\n    node.parentNode.removeChild(node);\n\n    return true;\n  },\n\n\n  /**\n   * Make an XHR request\n   *\n   * {\n   *   form: {selector} - form element to serialize and submit via xhr\n   *   url: '{string}',\n   *   method: '{GET|POST}',\n   *   headers: [],\n   *   params: {}\n   * }\n   *\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest\n   * @param {Object} config url, method, params, form\n   * @param {Function} handler invoked on completion\n   * @return {XMLHttpRequest} object making the request\n   */\n  xhrRequest = function xhrRequest(config, handler) {\n\n    if (typeof XMLHttpRequest === 'undefined') {\n      return null;\n    }\n\n    var defaults = {\n      form: null,\n      url: '/',\n      headers: {},\n      method: 'get',\n      params: {}\n    };\n\n    config = objectMerge(defaults, config);\n\n    if (config.form) {\n      config.form = getElement(config.form);\n      config.url = config.form.getAttribute('action'), config.method = config.form.getAttribute('method') ? config.form.getAttribute('method') : 'get', config.params = objectFromForm(config.form);\n    }\n\n    var xhttp = new XMLHttpRequest();\n    xhttp.onreadystatechange = function () {\n\n      if (this.readyState === 4) {\n        if (handler) {\n          handler(xhttp);\n        }\n      }\n    };\n\n    var url = config.url,\n        params = '';\n\n    if (config.form) {\n      var type = config.form.getAttribute('enctype');\n      if (type) {\n        config.headers['Content-Type'] = type;\n      }\n    }\n\n    if (config.method.toUpperCase() === 'GET') {\n      url = Object.keys(config.params).length > 0 ? url + '?' + queryString(config.params) : url;\n    } else {\n      // post\n      params = queryString(config.params);\n      config.headers['Content-Type'] = 'application/x-www-form-urlencoded';\n    }\n\n    config.headers['X-Requested-With'] = 'XMLHttpRequest';\n\n    xhttp.open(config.method, url, true);\n\n    for (var h in config.headers) {\n      if (config.headers.hasOwnProperty(h)) {\n        xhttp.setRequestHeader(h, config.headers[h]);\n      }\n    }\n\n    xhttp.send(params);\n\n    return xhttp;\n  },\n\n\n  /**\n   *\n   *\n   *\n   dataFromNode = function(node) {\n   },\n   */\n\n  /**\n   * Retrieve the last non-empty element of an array\n   *\n   * @param {Array} list - array to be iterated through\n   * @param {Function} func (optional) function used to evaluate items in the array\n   * @return {Mixed} the last non-empty value in the array (or `null` if no such value exists)\n   */\n  lastValue = function lastValue(list, func) {\n\n    list = arr(list);\n\n    var i = list.length - 1;\n    while (i >= 0) {\n      if (func ? func(list[i]) : list[i]) {\n        return list[i];\n      }\n      i--;\n    }\n\n    return null;\n  };\n\n  module.exports = {\n\n    Base64: Base64,\n\n    // document.body.addEventListener('keyup', function(e){ console.log(e.keyCode); });\n    Keyboard: {\n      next: 39,\n      previous: 37,\n      up: 38,\n      down: 40,\n      escape: 27,\n      enter: 13,\n      space: 32,\n      digits: [49, 50, 51, 52, 53, 54, 55, 56, 57, 48], // treat 0 zero as the last ordinal\n\n      /**\n       * Determine if a keyboardEvent has a modifier key associated\n       *\n       * @param {KeyboardEvent} e the event\n       * @return {Bool} `true` if event has a modifier key attached (control, shift, command, alt, etc.); `false` if not\n       */\n      hasModifier: function hasModifier(e) {\n        return e.metaKey || e.altKey || e.ctrlKey || e.shiftKey;\n      },\n\n      /**\n       * Return the ordinal (0-9) of a keypress; -1 if N/A, key \"0\" return ordinal 9\n       *\n       * @param {Integer|Event} keyCode either the key code or the window event for a `keypress`\n       * @return {Integer} ordinal for the key, or -1 if N/A\n       */\n      ordinal: function ordinal(keyCode) {\n\n        keyCode = parseInt(typeof keyCode !== 'number' ? keyCode.keyCode : keyCode, 10);\n\n        if (keyCode === 48) {\n          return 9;\n        } else if (keyCode >= 49 && keyCode <= 57) {\n          return keyCode - 49;\n        }\n\n        return -1;\n      }\n    },\n\n    Date: {\n\n      /**\n       * Convert a Date instance to RFC 3339 format, ex: `2019-01-17T17:55:48Z`\n       *\n       * @param {Date} date to be formatted, optional\n       * @return {String} Date in RFC 3339 format\n       * @see https://tools.ietf.org/html/rfc3339\n       */\n      toRFC3339: function toRFC3339(date) {\n\n        if (!date) {\n          date = new Date();\n        }\n\n        var pad = function pad(n) {\n          return n < 10 ? '0' + n : n;\n        };\n\n        return date.getUTCFullYear() + '-' + pad(date.getUTCMonth() + 1) + '-' + pad(date.getUTCDate()) + 'T' + pad(date.getUTCHours()) + ':' + pad(date.getUTCMinutes()) + ':' + pad(date.getUTCSeconds()) + 'Z';\n      },\n\n      fromRFC3339: function fromRFC3339(dString) {\n\n        if (!dString) {\n          return null;\n        }\n\n        return new Date(dString);\n\n        var ret = new Date();\n\n        var utcOffset = void 0,\n            offsetSplitChar = void 0;\n        var offsetMultiplier = 1;\n        var dateTime = dString.split(\"T\");\n        var date = dateTime[0].split(\"-\");\n        var time = dateTime[1].split(\":\");\n        var offsetField = time[time.length - 1];\n        var offsetString = void 0;\n\n        var offsetFieldIdentifier = offsetField.charAt(offsetField.length - 1);\n        if (offsetFieldIdentifier === \"Z\") {\n          utcOffset = 0;\n          time[time.length - 1] = offsetField.substr(0, offsetField.length - 2);\n        } else {\n          if (offsetField[offsetField.length - 1].indexOf(\"+\") !== -1) {\n            offsetSplitChar = \"+\";\n            offsetMultiplier = 1;\n          } else {\n            offsetSplitChar = \"-\";\n            offsetMultiplier = -1;\n          }\n          offsetString = offsetField.split(offsetSplitChar);\n          time[time.length - 1] === offsetString[0];\n          offsetString = offsetString[1].split(\":\");\n          utcOffset = offsetString[0] * 60 + offsetString[1];\n          utcOffset = utcOffset * 60 * 1000;\n        }\n\n        ret.setTime(Date.UTC(date[0], date[1] - 1, date[2], time[0], time[1], time[2]) + utcOffset * offsetMultiplier);\n        return ret;\n      }\n    },\n\n    OS: {\n      isApple: function isApple() {\n        var agent = window.navigator.userAgent;\n        return agent.match('iPhone;') || agent.match('iPad;') || agent.match('iPod;') || agent.match('Mac OS X');\n      }\n    },\n    Browser: {\n      isTouch: isTouch,\n      isSafari: isSafari,\n      isFirefox: isFirefox,\n      scrollTo: scrollTo,\n      opensData: opensData\n    },\n    String: {\n      isURL: isURL,\n      guid: guid,\n      localize: localize\n    },\n    Array: {\n      coerce: arr,\n      last: lastValue,\n      remove: arrayRemove,\n      find: arrayFind,\n      reorder: arrayReorder\n    },\n    Object: {\n      keys: objectKeys,\n      merge: objectMerge,\n      value: objectGet,\n      fromForm: objectFromForm,\n      queryString: queryString,\n      has: objectHas\n    },\n    XHR: {\n      request: xhrRequest\n    },\n    Map: {\n      formatLatitude: formatLatitude,\n      formatLongitude: formatLongitude\n    },\n    Node: {\n      //      data: dataFromNode,\n      ancestor: ancestor,\n      matches: selectorMatches,\n      remove: removeNode,\n      loader: loader,\n      get: getElement,\n      getAll: getElements,\n      prune: pruneElement,\n      listen: addListener,\n\n      // TODO: deprecate `make`\n      //      make: makeElement,\n      create: makeElement,\n      getRect: getRect,\n      setStyles: setStyles\n    }\n  };\n\n  if (typeof window !== 'undefined') {\n    window.document.addEventListener('DOMContentLoaded', function () {\n      document.body.classList.add('rmr-js');\n\n      if (isTouch()) {\n        document.body.classList.add('rmr-touch');\n\n        var resizer = function resizer() {\n\n          var body = document.body,\n              cls = window.innerWidth > window.innerHeight ? 'rmr-landscape' : 'rmr-portrait';\n\n          body.classList.remove('rmr-landscape');\n          body.classList.remove('rmr-portrait');\n\n          body.classList.add(cls);\n        };\n\n        window.addEventListener('orientationchange', function () {\n          resizer();\n        });\n\n        resizer();\n      } else {\n        var body = document.body,\n            hover = 'rmr-hover',\n            out = 'rmr-nohover';\n\n        body.addEventListener('mouseenter', function () {\n          body.classList.add(hover);\n          body.classList.remove(out);\n        });\n\n        body.addEventListener('mouseleave', function () {\n          body.classList.remove(hover);\n          body.classList.add(out);\n        });\n      }\n    });\n  }\n\n  /*\n    (function() {\n      var elements = ['section', 'article', 'aside', 'header', 'footer', 'nav', 'figure', 'figcaption', 'time', 'mark', 'main'];\n      for (const i in elements) {\n        if (elements.hasOwnProperty(i)) {\n          console.log(elements[i]);\n          document.createElement(elements[i]);\n        }\n      }\n    })();\n  */\n})();\n\n//# sourceURL=webpack:///./node_modules/rmr-util/index.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/* jshint undef: true,strict:true,trailing:true,loopfunc:true */\n/* global document,window,Element,module,require */\n\n(function () {\n\n  \"use strict\";\n\n  window.Popover = __webpack_require__(/*! ./scripts/rmr-popover.js */ \"./src/scripts/rmr-popover.js\");\n})();\n\n//# sourceURL=webpack:///./src/index.js?");

/***/ }),

/***/ "./src/scripts/rmr-popover.js":
/*!************************************!*\
  !*** ./src/scripts/rmr-popover.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/* jshint undef: true,strict:true,trailing:true,loopfunc:true */\n/* global document,window,Element,module */\n\n(function () {\n  'use strict';\n\n  var RMR = __webpack_require__(/*! rmr-util */ \"./node_modules/rmr-util/index.js\"),\n\n\n  // VERSION = '0.1.9',\n\n  // default attribute on target nodes that will be inspected for popover data\n  ATTR = 'data-popover',\n\n\n  // default background color for popovers\n  COLOR = 'rgba(0,0,0,0.8)',\n\n\n  // offset of popover from target node\n  MARGIN = 0,\n\n\n  /*\n   * Generate a unique string suitable for id attributes\n   *\n   * @param basename (String)\n   * @return string\n   */\n  guid = RMR.String.guid,\n\n\n  /*\n   * Merge two objects into one, values in b take precedence over values in a\n   *\n   * @param a {Object}\n   * @param b {Object}\n    * @return Object\n   */\n  merge = RMR.Object.merge,\n\n\n  /*\n   * Convert an array-like thing (ex: NodeList or arguments object) into a proper array\n   *\n   * @param list (array-like thing)\n   * @return Array\n   */\n  arr = RMR.Array.coerce,\n\n\n  /*\n   * Create an element with a set of attributes/values\n   *\n   * @param type (String)\n   * @param attrs {Object}\n   *\n   * @return HTMLElement\n   */\n  makeElement = RMR.Node.create,\n\n\n  /*\n   * Retrieve an object containing { top : xx, left : xx, bottom: xx, right: xx, width: xx, height: xx }\n   *\n   * @param node (DOMNode)\n   */\n  getRect = RMR.Node.getRect,\n\n\n  /*\n   * Retrieve object containing popover data for an element on the page\n   *\n   * @param scope {Popover}\n   * @param node {\n   * @return {Object}\n   */\n  getDataForNode = function getDataForNode(scope, node) {\n    var val = scope.factory ? scope.factory(node) : node.getAttribute(scope.attribute);\n    var data = scope.defaults;\n\n    if ((typeof val === 'undefined' ? 'undefined' : _typeof(val)) !== \"object\") {\n      try {\n        val = JSON.parse(val);\n\n        if (typeof val === 'number') {\n          val = { content: val };\n        }\n      } catch (err) {\n        val = { content: val };\n      }\n    }\n\n    var ret = merge(data, val);\n    ret.id = ret.hasOwnProperty('id') && ret.id ? ret.id : node.getAttribute('id') + '-popover';\n\n    return ret;\n  },\n\n\n  /*\n   *\n   * @param node {HTMLElement}\n   * @param styles {Object}\n   */\n  setStyles = RMR.Node.setStyles,\n\n\n  /*\n   * Position a popover relative to its target parent\n   *\n   * @param popover {HTMLElement} - the popover element\n   * @param target {HTMLElement} - the reference element for the popover\n   * @param data {Object} - object containing data for the popover\n   */\n  positionPopover = function positionPopover(popover, target, data) {\n\n    var targetRect = getRect(target),\n        popoverRect = getRect(popover),\n        arrow = popover.querySelector('.arrow'),\n        arrowOffset = 5;\n\n    var popoverXY = [0, 0],\n        // position of the popover in absolute window coordinates\n    arrowXY = [0, 0]; // position of the arrow relative to the popover rect\n\n    // set default location for popover\n    popoverXY = [targetRect.left + targetRect.width / 2 - popoverRect.width / 2, targetRect.top - popoverRect.height - arrowOffset - data.margin];\n\n    arrowXY = [popoverXY[0], popoverXY[1]];\n    arrowXY[0] = popoverRect.width / 2 - arrowOffset;\n\n    var placeTopBottom = function placeTopBottom(popoverXY, arrowXY) {\n\n      popoverXY = [targetRect.left + targetRect.width / 2 - popoverRect.width / 2, targetRect.top - popoverRect.height - arrowOffset - data.margin];\n\n      arrowXY = [popoverXY[0], popoverXY[1]];\n      arrowXY[0] = popoverRect.width / 2 - arrowOffset;\n\n      arrow.style.borderLeftColor = 'transparent';\n      arrow.style.borderRightColor = 'transparent';\n\n      if (popoverXY[1] - window.pageYOffset < 0) {\n        // clipped at top of browser?\n        arrowXY[1] = 0 - arrowOffset * 2;\n        popoverXY[1] = targetRect.bottom + arrowOffset + data.margin;\n\n        arrow.style.borderBottom = '5px solid ' + data.color;\n        popover.classList.add('bottom');\n      } else {\n        // top\n        arrowXY[1] = popoverRect.height;\n        arrow.style.borderTopColor = data.color;\n      }\n\n      if (popoverXY[0] < 0) {\n        // are we clipped on the left of the browser window ?\n        popoverXY[0] = arrowOffset;\n        arrowXY[0] = targetRect.left + targetRect.width / 2 - 2 * arrowOffset;\n      } else if (popoverXY[0] < targetRect.left) {\n        // is the popover further left than the target?\n        popoverXY[0] = targetRect.left - arrowOffset;\n        arrowXY[0] = targetRect.width / 2;\n      }\n\n      if (popoverXY[0] + popoverRect.width > window.innerWidth) {\n        // are we clipped on the right side of the browser window?\n        popoverXY[0] = window.innerWidth - popoverRect.width - 5;\n        arrowXY[0] = targetRect.left - popoverXY[0] + targetRect.width / 2 - arrowOffset;\n      }\n\n      return [popoverXY, arrowXY];\n    };\n\n    if (!data.position || data.position !== \"side\") {\n      // assume top of target\n\n      var ret = placeTopBottom(popoverXY, arrowXY);\n      popoverXY = ret[0];\n      arrowXY = ret[1];\n    } else {\n      // right-side of target\n      popoverXY[0] = targetRect.left + targetRect.width + arrowOffset + data.margin;\n      popoverXY[1] = targetRect.top + targetRect.height / 2 - popoverRect.height / 2;\n\n      arrow.style.borderRightColor = data.color;\n\n      if (popoverXY[1] - window.pageYOffset < 0) {\n        popoverXY[1] = window.pageYOffset + data.margin;\n        arrowXY[1] = arrowOffset;\n      } else {\n        arrowXY[1] = popoverRect.height / 2 - arrowOffset;\n      }\n\n      arrowXY[0] = 0 - 2 * arrowOffset;\n\n      if (popoverXY[0] + popoverRect.width > window.innerWidth) {\n        // if clipped on right side, move to the left\n\n        popoverXY[0] = targetRect.left - popoverRect.width - 5 - data.margin;\n        popover.classList.add('left');\n        arrowXY[0] = popoverRect.width;\n\n        arrow.style.borderRightColor = 'transparent';\n        arrow.style.borderLeftColor = data.color;\n      }\n\n      if (popoverXY[0] < 0) {\n        // if also clipped on the left side, move to top/bottom\n        var _ret = placeTopBottom(popoverXY, arrowXY);\n        popoverXY = _ret[0];\n        arrowXY = _ret[1];\n      }\n    }\n\n    setStyles(popover, { left: parseInt(popoverXY[0], 10) + 'px', top: parseInt(popoverXY[1], 10) + 'px', backgroundColor: data.color });\n    setStyles(arrow, { left: parseInt(arrowXY[0], 10) + 'px', top: parseInt(arrowXY[1], 10) + 'px' });\n  },\n      timeouts = {},\n      // store window.setTimeout handles for popover hiding\n  pops = {}; // store popover HTMLElements keyed by their id attribute\n\n  /**\n   *\n   *\n   * @param {Object} config (optional) - control behaviour of Popover object\n   * @param {Object} defaults (optional) - default properties for individual popover elements\n   */\n  var Popover = function Popover(config, defaults) {\n    var self = this,\n        defaultConfig = {\n      attribute: ATTR,\n      debug: false,\n      root: document.body,\n      delay: { pop: 200, unpop: 300 },\n      factory: null\n    },\n        defaultProperties = {\n      color: COLOR,\n      margin: MARGIN,\n      cache: false,\n      'class': ''\n    },\n\n\n    /*\n     *\n     * @param e {MouseEvent} - mouseevent for the target element\n     * @param delay {Int}\n     */\n    _off = function _off(e, delay) {\n      var target = e.target,\n          f = function f() {\n        // const id = target.getAttribute('id');\n        target.removeAttribute('aria-describedBy');\n        try {\n          var _data = getDataForNode(self, target),\n              pop = pops[_data.id];\n\n          if (pop) {\n            if (!self.debug) {\n\n              self.events.unpop(target, pop);\n              if (!_data.cache) {\n\n                delete timeouts[target.getAttribute('id')];\n                delete pops[_data.id];\n                pop.parentNode.removeChild(pop);\n              } else {\n                pop.classList.remove('pop');\n              }\n            }\n          }\n        } catch (e) {\n          if (self.debug) {\n            window.console.log('ERROR', e);\n          }\n        }\n      };\n\n      timeouts[target.getAttribute('id')] = window.setTimeout(f, arguments.length === 1 ? self.delay.unpop : delay);\n    },\n\n\n    /* Invoked when mouse hovers over the popover element\n     *\n     * @param e {MouseEvent}\n     */\n    over = function over(e) {\n      var n = e.target,\n          id = n.getAttribute('data-target');\n\n      n.addEventListener('mouseleave', function () {\n        _off({ target: document.getElementById(id) });\n      });\n\n      if (timeouts[id]) {\n        window.clearTimeout(timeouts[id]);\n        delete timeouts[id];\n      }\n    },\n\n\n    /* Invoked when the mouse enters the popover target element\n     *\n     * @param e {MouseEvent}\n     * @param delay {Int} - number of milliseconds to delay\n     */\n    _on = function _on(e, delay) {\n\n      if (!self.enabled) {\n        return;\n      }\n\n      var target = e.target,\n          data = getDataForNode(self, target);\n\n      data.class = (data.class ? data.class : '') + (data.position === \"side\" ? ' side' : ' top') + ' rmr-popover' + (data.persist ? ' persist' : '');\n\n      var n = document.querySelector('#' + data.id);\n      if (!n) {\n        // if the node exists, then the popover is visible & don't need to proceed\n        n = makeElement('div', { 'data-target': target.getAttribute('id'), role: 'tooltip', class: data.class, id: data.id });\n      } else {\n        window.clearTimeout(timeouts[target.getAttribute('id')]);\n        n.classList.add('pop');\n        return;\n      }\n\n      var popper = function popper() {\n        if (n) {\n          n.classList.add('pop');\n          if (pops[n.getAttribute('id')]) {\n            // fire event listener\n            self.events.pop(target, n);\n          }\n        }\n      };\n\n      if (self.debug) {\n        window.console.log(data);\n      }\n\n      var reference = null;\n\n      if (data.node) {\n\n        reference = RMR.Node.get(data.node);\n        if (!reference) {\n          console.warn('Invalid reference node ' + data.node + ' for popover');\n        }\n        reference = reference.cloneNode(true);\n        reference.removeAttribute('aria-hidden');\n      }\n\n      // if a popover with this id already exists, don't display the one we just created\n\n      // if there's no content and no specific class, abort since it's an empty popover\n      if (!data.content && !data.class && !reference && !data.url) {\n        return;\n      }\n\n      var show = function show(content) {\n\n        if (!n.parentNode) {\n          n.innerHTML = '<b class=\"arrow\"></b><div class=\"bd\">' + content + '</div>';\n          window.document.body.appendChild(n);\n        }\n\n        if (reference) {\n          var bd = n.querySelector('div.bd');\n          bd.innerHTML = '';\n          bd.appendChild(reference);\n        }\n\n        target.setAttribute('aria-describedby', data.id);\n\n        positionPopover(n, target, data);\n\n        pops[data.id] = n;\n\n        window.setTimeout(function () {\n          popper();\n        }, delay ? delay : 0);\n\n        //\n        if (!data.persist) {\n          n.addEventListener('mouseenter', over);\n        }\n\n        //        n.setAttribute('data-shown', true);\n      };\n\n      if (data.url && !n.parentNode) {\n        RMR.XHR.request({ url: data.url }, function (xhr) {\n          if (xhr.status === 200) {\n            show(xhr.responseText);\n          } else {\n            if (self.debug) {\n              window.console.error('Popover XHR request failed', data.url);\n            }\n          }\n        });\n      } else {\n        //        window.document.body.appendChild(n);\n        show(data.content ? data.content : '');\n      }\n    };\n\n    config = merge(defaultConfig, config);\n\n    var nodes = null,\n        i = 0,\n        n = null,\n        node = null,\n        l = null,\n        data = null;\n\n    if (!config.hasOwnProperty('delay')) {\n      config.delay = defaultConfig.delay;\n    } else if (typeof config.delay === 'number') {\n      config.delay = { pop: config.delay, unpop: config.delay };\n    }\n\n    config = merge(defaultConfig, config);\n    this.defaults = merge(defaultProperties, defaults);\n\n    // two events are fired\n    this.events = {\n      pop: function pop() /* target, popover*/{},\n      unpop: function unpop() /* target, popover*/{}\n    };\n    this.enabled = true;\n    this.attribute = config.attribute;\n    this.delay = config.delay;\n    this.cache = config.cache;\n    this.factory = config.factory;\n    this.debug = config.debug;\n    this.listeners = {};\n\n    node = config.root ? config.root instanceof Element ? config.root : document.querySelector(config.root) : document.body;\n\n    if (!node) {\n      throw Error('Invalid Popover root [' + config.root + ']');\n    }\n\n    this.root = node;\n\n    if (this.factory) {\n      nodes = [this.root];\n    } else {\n      //\n      nodes = arr(node.querySelectorAll('[' + this.attribute + ']'));\n\n      // add root node if it has the data-popover attribute\n      if (node.hasAttribute(this.attribute)) {\n        nodes.push(node);\n      }\n    }\n    // init\n\n    for (i = 0; i < nodes.length; i++) {\n      n = nodes[i];\n\n      // ensure target has unique id\n      if (!n.getAttribute('id')) {\n        n.setAttribute('id', guid('popover-target-'));\n      }\n\n      // clear out title since we don't want the tooltip to obscure the popover\n      if (n.hasAttribute('title')) {\n        n.setAttribute('title', '');\n      }\n\n      l = {\n        on: function on(e) {\n          _on(e, self.delay.pop);\n        },\n        off: function off(e) {\n          _off(e, self.delay.unpop);\n        }\n      };\n      data = getDataForNode(this, n);\n\n      this.listeners[n.getAttribute('id')] = {\n        pop: l.on,\n        unpop: l.off\n      };\n\n      if (data.persist) {\n        // if this is a persistent popover, create it immediately\n        l.on({ target: n });\n        //        positionPopover(RMR.Node.get('#' + n.getAttribute('aria-describedby')), n, getDataForNode(self, n));\n      } else {\n        // otherwise attach the necessary listeners for mouse/touch interaction\n        if (data.events && data.events.pop) {\n          n.addEventListener(data.events.pop, l.on);\n        } else {\n          n.addEventListener('touchstart', l.on);\n          n.addEventListener('mouseenter', l.on);\n        }\n\n        if (data.events && data.events.unpop) {\n          n.addEventListener(data.events.unpop, l.off);\n        } else {\n          n.addEventListener('touchend', l.off);\n          n.addEventListener('mouseleave', l.off);\n        }\n      }\n    }\n\n    /*\n     * Re-position all persistent popovers on window resize\n     */\n    this.windowResizer = function () {\n      var target = null,\n          i = 0;\n\n      var persists = arr(document.querySelectorAll('.rmr-popover.persist'));\n\n      for (i = 0; i < persists.length; i++) {\n        target = document.getElementById(persists[i].getAttribute('data-target'));\n\n        positionPopover(persists[i], target, getDataForNode(this, target));\n      }\n    };\n\n    window.addEventListener('resize', function windowResize() {\n      self.windowResizer();\n    });\n\n    // position persistent popovers\n    window.setTimeout(function () {\n      self.windowResizer();\n    }, 0);\n\n    this.set = function (key, value) {\n      if (!this.defaults.hasOwnProperty(key)) {\n        throw new Error('Invalid key ', key);\n      }\n      this.defaults[key] = value;\n    };\n\n    this.destroy = function () {\n      var n = void 0,\n          data = void 0,\n          i = void 0;\n      for (i in this.listeners) {\n        if (!this.listeners.hasOwnProperty(i)) {\n          continue;\n        }\n\n        n = document.getElementById(i);\n        if (!n) {\n          continue;\n        }\n        data = getDataForNode(this, n);\n\n        if (data.events && data.events.pop) {\n          n.removeEventListener(data.events.pop, this.listeners[i].pop);\n        } else {\n          n.removeEventListener('mouseenter', this.listeners[i].pop);\n          n.removeEventListener('touchstart', this.listeners[i].pop);\n        }\n\n        if (data.events && data.events.unpop) {\n          n.removeEventListener(data.events.unpop, this.listeners[i].unpop);\n        } else {\n          n.removeEventListener('mouseleave', this.listeners[i].unpop);\n          n.removeEventListener('touchend', this.listeners[i].unpop);\n        }\n\n        // remove all popovers\n        _off({ target: n }, 0);\n      }\n\n      // remove resize listener\n      window.removeEventListener('resize', this.windowResizer);\n\n      return this;\n    };\n\n    if (this.debug) {\n      window.console.log(this.toString());\n    }\n\n    this.windowResizer();\n  };\n\n  /**\n   * Attach a listener to `pop`/`unpop` events\n   *\n   * @param {String} event - one of `pop` or `unpop`\n   * @param {Function} method - the method that will be invoked on the relevant event\n   * @return {Object} - instance for chaining\n   * @chainable\n   */\n  Popover.prototype.on = function (event, method) {\n    this.events[event] = method;\n    return this;\n  };\n\n  /**\n   * Return a string representation of the instance\n   *\n   * @return {String} description of object\n   */\n  Popover.prototype.toString = function () {\n    return 'Popover ' + JSON.stringify({ root: '' + this.root, enabled: this.enabled, delay: this.delay, debug: this.debug });\n  };\n\n  module.exports = Popover;\n})();\n\n//# sourceURL=webpack:///./src/scripts/rmr-popover.js?");

/***/ })

/******/ });