/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/rmr-util/index.js":
/*!****************************************!*\
  !*** ./node_modules/rmr-util/index.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/* global require, module, console, Promise */\n\n(function () {\n\n  'use strict';\n\n  /**\n   * rmr-util\n   *\n   * JS for your browser\n   *\n   *\n   *\n   */\n\n  var\n\n  /**\n   * Determine if a string is a valid internet URL\n   *\n   * @param {String} str - the string to be tested\n   * @return {Bool} - `true` of `false`\n   */\n  isURL = function isURL(str) {\n    // ???\n    return (/^(?:(?:(?:https?|ftp):)?\\/\\/)(?:\\S+(?::\\S*)?@)?(?:(?!(?:10|127)(?:\\.\\d{1,3}){3})(?!(?:169\\.254|192\\.168)(?:\\.\\d{1,3}){2})(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,})))(?::\\d{2,5})?(?:[/?#]\\S*)?$/i.test(str)\n    );\n  },\n\n\n  /**\n   * Determine if a node matches a provided selector\n   *\n   * @param {HTMLElement} node  the element to be tested\n   * @param {String} selector the selector string to test\n   * @return {Bool} `true` or `false`\n   */\n  selectorMatches = function selectorMatches(node, selector) {\n\n    var p = Element.prototype,\n        f = p.matches || p.webkitMatchesSelector || p.mozMatchesSelector || p.msMatchesSelector || function (s) {\n      return [].indexOf.call(document.querySelectorAll(s), this) !== -1;\n    };\n\n    return f.call(node, selector);\n  },\n\n\n  /**\n   * Determine if we're in a touch-based browser (phone/tablet)\n   *\n   * @return {Bool} `true` or `false`\n   */\n  isTouch = function isTouch() {\n\n    if (typeof window === 'undefined' || typeof navigator === 'undefined') {\n      return false;\n    }\n\n    return typeof window.orientation !== 'undefined';\n\n    //    return 'ontouchstart' in window || navigator.msMaxTouchPoints;\n  },\n\n\n  /*\n   * Generate a unique string suitable for id attributes\n   *\n   * @param basename (String)\n   * @return string\n   */\n  guid = function guid(basename) {\n    return (basename ? basename : 'rmr-guid-') + parseInt(Math.random() * 100, 10) + '-' + parseInt(Math.random() * 1000, 10);\n  },\n\n\n  /*\n   * Merge two objects into one, values in b take precedence over values in a\n   *\n   * @param a {Object}\n   * @param b {Object}\n    * @return Object\n   */\n  merge = function merge(a, b) {\n    var o = {};\n    var i = null;\n    for (i in a) {\n      if (a.hasOwnProperty(i)) {\n        o[i] = a[i];\n      }\n    }\n    if (!b) {\n      return o;\n    }\n    for (i in b) {\n      if (b.hasOwnProperty(i)) {\n        o[i] = b[i];\n      }\n    }\n    return o;\n  },\n\n\n  /**\n   * Convert an array-like thing (ex: NodeList or arguments object) into a proper array, or convert a scalar into a single-element array\n   *\n   * @param {Mixed} list an array-like thing or a scalar\n   * @return {Array} the param as an array\n   */\n  arr = function arr(list) {\n\n    var ret = [];\n    var i = 0;\n\n    if (list instanceof Array) {\n      return list;\n    }\n\n    if (typeof list.length !== 'number') {\n      return [list];\n    }\n\n    for (i = 0; i < list.length; i++) {\n      ret.push(list[i]);\n    }\n\n    return ret;\n  },\n\n\n  /**\n   * Remove an object from an array\n   *\n   * @param {Array} array containing object to be removed\n   * @param {Any} item to be removed\n   * @return {Array} array for chaining\n   */\n  arrayRemove = function arrayRemove(array, item) {\n    return arr(array).filter(function (e) {\n      return e !== item;\n    });\n  },\n\n\n  /**\n   * Retrieve an element via query selector\n   *\n   * @param {Mixed} arg the element to retrieve\n   * @return {Element} element corresponding to the selector (or null if none exists)\n   */\n  getElement = function getElement(arg) {\n    if (typeof arg === 'string') {\n      return document.querySelector(arg);\n    }\n\n    return arg;\n  },\n\n\n  /*\n   * Create an element with a set of attributes/values\n   *\n   * @param type (String)\n   * @param attrs {Object}\n   *\n   * @return HTMLElement\n   */\n  makeElement = function makeElement(type, attrs) {\n\n    var n = document.createElement(type);\n\n    for (var i in attrs) {\n      if (attrs.hasOwnProperty(i) && attrs[i]) {\n        n.setAttribute(i, attrs[i]);\n      }\n    }\n    return n;\n  },\n\n\n  /**\n   * Make loader\n   *\n   * @return {String} SVG element\n   */\n  loader = function loader() {\n\n    /*\n        const svg = makeElement('svg', {\n          version: '1.1',\n          class: 'rmr-loader',\n          xmlns: 'http://www.w3.org/2000/svg',\n          'xmlns:xlink': 'http://www.w3.org/1999/xlink',\n          x: '0px',\n          y: '0px',\n          width: '40px',\n          height: '40px',\n          viewBox: '0 0 40 40',\n          'enable-background': 'new 0 0 40 40',\n          'xml:space': 'preserve'\n        });\n    \n        svg.innerHTML =\n        '<path opacity=\"0.2\" fill=\"#000\" d=\"M20.201,5.169c-8.254,0-14.946,6.692-14.946,14.946c0,8.255,6.692,14.946,14.946,14.946 s14.946-6.691,14.946-14.946C35.146,11.861,28.455,5.169,20.201,5.169z M20.201,31.749c-6.425,0-11.634-5.208-11.634-11.634 c0-6.425,5.209-11.634,11.634-11.634c6.425,0,11.633,5.209,11.633,11.634C31.834,26.541,26.626,31.749,20.201,31.749z\"></path>' +\n        '<path fill=\"#000\" d=\"M26.013,10.047l1.654-2.866c-2.198-1.272-4.743-2.012-7.466-2.012h0v3.312h0 C22.32,8.481,24.301,9.057,26.013,10.047z\">' +\n        '<animateTransform attributeType=\"xml\" attributeName=\"transform\" type=\"rotate\" from=\"0 20 20\" to=\"360 20 20\" dur=\"0.8s\" repeatCount=\"indefinite\"></animateTransform>' +\n        '</path>';\n    */\n\n    return '<svg version=\"1.1\" class=\"rmr-loader\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" width=\"40px\" height=\"40px\" viewBox=\"0 0 40 40\" enable-background=\"new 0 0 40 40\" xml:space=\"preserve\">' + '<path opacity=\"0.2\" fill=\"#000\" d=\"M20.201,5.169c-8.254,0-14.946,6.692-14.946,14.946c0,8.255,6.692,14.946,14.946,14.946 s14.946-6.691,14.946-14.946C35.146,11.861,28.455,5.169,20.201,5.169z M20.201,31.749c-6.425,0-11.634-5.208-11.634-11.634 c0-6.425,5.209-11.634,11.634-11.634c6.425,0,11.633,5.209,11.633,11.634C31.834,26.541,26.626,31.749,20.201,31.749z\"></path>' + '<path fill=\"#000\" d=\"M26.013,10.047l1.654-2.866c-2.198-1.272-4.743-2.012-7.466-2.012h0v3.312h0 C22.32,8.481,24.301,9.057,26.013,10.047z\">' + '<animateTransform attributeType=\"xml\" attributeName=\"transform\" type=\"rotate\" from=\"0 20 20\" to=\"360 20 20\" dur=\"0.8s\" repeatCount=\"indefinite\"></animateTransform>' + '</path>' + '</svg>';\n\n    //    return svg;\n  },\n\n\n  /**\n   * Retrieve an object containing browser/screen coordinates for a DOM element\n   *\n   * @param {Element} node the element whose coordinates should be retrieved\n   * @return {Object} An object containing { top : xx, left : xx, bottom: xx, right: xx, width: xx, height: xx }\n   */\n  getRect = function getRect(node) {\n\n    node = getElement(node);\n    if (!node) {\n      return null;\n    }\n\n    var rect = node.getBoundingClientRect(),\n        ret = { top: rect.top, left: rect.left, bottom: rect.bottom, right: rect.right }; // create a new object that is not read-only\n\n    ret.top += window.pageYOffset;\n    ret.left += window.pageXOffset;\n\n    ret.bottom += window.pageYOffset;\n    ret.right += window.pageYOffset;\n\n    ret.width = rect.right - rect.left;\n    ret.height = rect.bottom - rect.top;\n\n    return ret;\n  },\n\n\n  /**\n   * Localize a string\n   *\n   * {\n   *   'en' : {\n   *      'key' : 'neighbor'\n   *    },\n   *    'en-ca' : {\n   *      'key' : 'neighbour'\n   *    }\n   *  }\n   *\n   * @param {Object} lookup dictionary\n   * @param {String} key the to localize\n   * @return {String} string\n   */\n  localize = function localize(lookup, key) {\n\n    if (typeof navigator === 'undefined') {\n      return key;\n    }\n\n    var i = void 0,\n        lang = void 0;\n\n    for (i in navigator.languages) {\n      if (!navigator.languages.hasOwnProperty(i)) {\n        continue;\n      }\n      lang = navigator.languages[i].toLowerCase();\n      if (lookup.hasOwnProperty(lang) && lookup[lang].hasOwnProperty(key)) {\n        return lookup[lang][key];\n      }\n    }\n\n    for (i in navigator.languages) {\n      if (!navigator.languages.hasOwnProperty(i)) {\n        continue;\n      }\n      lang = navigator.languages[i].split('-')[0].toLowerCase();\n      if (lookup.hasOwnProperty(lang) && lookup[lang].hasOwnProperty(key)) {\n        return lookup[lang][key];\n      }\n    }\n\n    //    console.warn('No localization for ' + key);\n    return key;\n  },\n\n\n  /**\n   * Apply styles to a node\n   *\n   * @param {HTMLElement} node that should have styles applied\n   * @param {Object} styles key/value pairs for styles and values\n   * @return {Element} node\n   */\n  setStyles = function setStyles(node, styles) {\n\n    node = getElement(node);\n    if (!node) {\n      return false;\n    }\n\n    for (var i in styles) {\n      if (styles.hasOwnProperty(i) && styles[i]) {\n        node.style[i] = styles[i];\n      }\n    }\n\n    return node;\n  },\n\n\n  /**\n   * Build a query string from an object\n   *\n   * @param {Object} obj the object to be passed via URL\n   * @return {String} str query string corresponding to the object\n   */\n  queryString = function queryString(obj) {\n\n    if (Object.keys(obj).length === 0) {\n      return '';\n    }\n\n    return Object.keys(obj).reduce(function (a, k) {\n      a.push(k + '=' + encodeURIComponent(obj[k]));\n      return a;\n    }, []).join('&');\n  },\n\n\n  /**\n   * Generate an object containing keys/values corresponding to form elements\n   *\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/FormData/Using_FormData_Objects\n   * @param {Element} form element\n   * @return {Object} the key/value pairs for the form\n   */\n  objectFromForm = function objectFromForm(form) {\n\n    form = getElement(form);\n    if (!form) {\n      return {};\n    }\n\n    if (typeof FormData !== 'undefined') {\n      //      const f = new FormData(form);\n      //      console.log(f);\n      //      return f;\n    }\n\n    var inputs = form.querySelectorAll('select,input,textarea'),\n        params = {};\n\n    for (var i in inputs) {\n      if (!inputs.hasOwnProperty(i)) {\n        continue;\n      }\n      var name = inputs[i].getAttribute('name'),\n          type = inputs[i].type ? inputs[i].type : 'text';\n\n      if (inputs[i].hasAttribute('disabled')) {\n        continue;\n      }\n\n      if (type === 'radio' || type === 'checkbox') {\n        if (inputs[i].checked) {\n          params[name] = inputs[i].value;\n        }\n      } else {\n        params[name] = inputs[i].value;\n      }\n    }\n\n    return params;\n  },\n\n\n  /**\n   * Get a node's ancestor\n   *\n   * @param {Element} node starting point of search\n   * @param {String} ancestor the selector for the ancestor we're looking for\n   * @param {Bool} includeSelf optionally include starting point in search\n   * @return {Element} or `null` if no such ancestor exists\n   */\n  ancestor = function ancestor(node, _ancestor, includeSelf) {\n\n    node = getElement(node);\n    if (!node) {\n      return null;\n    }\n\n    if (includeSelf && selectorMatches(node, _ancestor)) {\n      return node;\n    }\n\n    var parent = node;\n\n    while ((parent = parent.parentNode) !== null) {\n      if (selectorMatches(parent, _ancestor)) {\n        return parent;\n      }\n    }\n\n    return null;\n  },\n\n\n  /**\n   * Remove a DOM node from the document\n   *\n   * @param {Element} node the node to be removed\n   * @return {Bool} `true` if removed'; `false` if the node doesn't exist\n   */\n  removeNode = function removeNode(node) {\n\n    node = getElement(node);\n    if (!node) {\n      return false;\n    }\n\n    node.parentNode.removeChild(node);\n\n    return true;\n  },\n\n\n  /**\n   * Make an XHR request\n   *\n   * {\n   *   form: {selector} - form element to serialize and submit via xhr\n   *   url: '{string}',\n   *   method: '{GET|POST}',\n   *   headers: [],\n   *   params: {}\n   * }\n   *\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest\n   * @param {Object} config url, method, params, form\n   * @param {Function} handler invoked on completion\n   * @return {XMLHttpRequest} object making the request\n   */\n  xhrRequest = function xhrRequest(config, handler) {\n\n    if (typeof XMLHttpRequest === 'undefined') {\n      return null;\n    }\n\n    var defaults = {\n      form: null,\n      url: '/',\n      headers: {},\n      method: 'get',\n      params: null\n    };\n\n    config = merge(defaults, config);\n\n    if (config.form) {\n      config.form = getElement(config.form);\n      config.url = config.form.getAttribute('action'), config.method = config.form.getAttribute('method') ? config.form.getAttribute('method') : 'get', config.params = objectFromForm(config.form);\n    }\n\n    var xhttp = new XMLHttpRequest();\n    xhttp.onreadystatechange = function () {\n\n      if (this.readyState === 4) {\n        if (handler) {\n          handler(xhttp);\n        }\n      }\n    };\n\n    var url = config.url,\n        params = '';\n\n    if (config.method.toUpperCase() === 'GET') {\n      url = config.params ? url + '?' + queryString(config.params) : url;\n    } else {\n      // post\n      params = queryString(config.params);\n      config.headers['Content-Type'] = 'application/x-www-form-urlencoded';\n    }\n\n    config.headers['X-Requested-With'] = 'XMLHttpRequest';\n\n    xhttp.open(config.method, url, true);\n\n    for (var h in config.headers) {\n      if (config.headers.hasOwnProperty(h)) {\n        xhttp.setRequestHeader(h, config.headers[h]);\n      }\n    }\n\n    xhttp.send(params);\n\n    return xhttp;\n  },\n\n\n  /**\n   *\n   *\n   *\n   dataFromNode = function(node) {\n   },\n   */\n\n  /**\n   * Retrieve the last non-empty element of an array\n   *\n   * @param {Array} list - array to be iterated through\n   * @param {Function} func (optional) function used to evaluate items in the array\n   * @return {Mixed} the last non-empty value in the array (or `null` if no such value exists)\n   */\n  lastValue = function lastValue(list, func) {\n\n    list = arr(list);\n\n    var i = list.length - 1;\n    while (i >= 0) {\n      if (func ? func(list[i]) : list[i]) {\n        return list[i];\n      }\n      i--;\n    }\n\n    return null;\n  };\n\n  module.exports = {\n    Browser: {\n      isTouch: isTouch\n    },\n    String: {\n      isURL: isURL,\n      guid: guid,\n      localize: localize\n    },\n    Array: {\n      coerce: arr,\n      last: lastValue,\n      remove: arrayRemove\n    },\n    Object: {\n      merge: merge,\n      fromForm: objectFromForm,\n      queryString: queryString\n    },\n    XHR: {\n      request: xhrRequest\n    },\n    Node: {\n      //      data: dataFromNode,\n      ancestor: ancestor,\n      matches: selectorMatches,\n      remove: removeNode,\n      loader: loader,\n      get: getElement,\n      make: makeElement,\n      getRect: getRect,\n      setStyles: setStyles\n    }\n  };\n\n  if (typeof window !== 'undefined') {\n    window.document.addEventListener('DOMContentLoaded', function () {\n      document.body.classList.add('rmr-js');\n    });\n  }\n\n  if (isTouch()) {\n\n    var resizer = function resizer() {\n\n      var body = document.body,\n          cls = window.innerWidth > window.innerHeight ? 'rmr-landscape' : 'rmr-portrait';\n\n      body.classList.remove('rmr-landscape');\n      body.classList.remove('rmr-portrait');\n\n      body.classList.add(cls);\n    };\n\n    window.addEventListener('orientationchange', function () {\n      resizer();\n    });\n\n    resizer();\n  };\n\n  (function () {\n    var elements = ['section', 'article', 'aside', 'header', 'footer', 'nav', 'figure', 'figcaption', 'time', 'mark', 'main'];\n    for (var i in elements) {\n      if (elements.hasOwnProperty(i)) {\n        console.log(elements[i]);\n        document.createElement(elements[i]);\n      }\n    }\n  })();\n})();\n\n//# sourceURL=webpack:///./node_modules/rmr-util/index.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/* jshint undef: true,strict:true,trailing:true,loopfunc:true */\n/* global document,window,Element,module,require */\n\n(function () {\n\n  \"use strict\";\n\n  window.Popover = __webpack_require__(/*! ./popover.js */ \"./src/popover.js\");\n})();\n\n//# sourceURL=webpack:///./src/index.js?");

/***/ }),

/***/ "./src/popover.js":
/*!************************!*\
  !*** ./src/popover.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/* jshint undef: true,strict:true,trailing:true,loopfunc:true */\n/* global document,window,Element,module */\n\n(function () {\n  'use strict';\n\n  var RMR = __webpack_require__(/*! rmr-util */ \"./node_modules/rmr-util/index.js\"),\n\n\n  // VERSION = '0.1.9',\n\n  // default attribute on target nodes that will be inspected for popover data\n  ATTR = 'data-popover',\n\n\n  // default background color for popovers\n  COLOR = 'rgba(0,0,0,0.8)',\n\n\n  // offset of popover from target node\n  MARGIN = 0,\n\n\n  /*\n   * Generate a unique string suitable for id attributes\n   *\n   * @param basename (String)\n   * @return string\n   */\n  guid = RMR.String.guid,\n\n\n  /*\n   * Merge two objects into one, values in b take precedence over values in a\n   *\n   * @param a {Object}\n   * @param b {Object}\n    * @return Object\n   */\n  merge = RMR.Object.merge,\n\n\n  /*\n   * Convert an array-like thing (ex: NodeList or arguments object) into a proper array\n   *\n   * @param list (array-like thing)\n   * @return Array\n   */\n  arr = RMR.Array.coerce,\n\n\n  /*\n   * Create an element with a set of attributes/values\n   *\n   * @param type (String)\n   * @param attrs {Object}\n   *\n   * @return HTMLElement\n   */\n  makeElement = RMR.Node.make,\n\n\n  /*\n   * Retrieve an object containing { top : xx, left : xx, bottom: xx, right: xx, width: xx, height: xx }\n   *\n   * @param node (DOMNode)\n   */\n  getRect = RMR.Node.getRect,\n\n\n  /*\n   * Retrieve object containing popover data for an element on the page\n   *\n   * @param scope {Popover}\n   * @param node {\n   * @return {Object}\n   */\n  getDataForNode = function getDataForNode(scope, node) {\n    var val = scope.factory ? scope.factory(node) : node.getAttribute(scope.attribute);\n    var data = scope.defaults;\n\n    if ((typeof val === 'undefined' ? 'undefined' : _typeof(val)) !== \"object\") {\n      try {\n        val = JSON.parse(val);\n\n        if (typeof val === 'number') {\n          val = { content: val };\n        }\n      } catch (err) {\n        val = { content: val };\n      }\n    }\n\n    var ret = merge(data, val);\n    ret.id = ret.hasOwnProperty('id') && ret.id ? ret.id : node.getAttribute('id') + '-popover';\n\n    return ret;\n  },\n\n\n  /*\n   *\n   * @param node {HTMLElement}\n   * @param styles {Object}\n   */\n  setStyles = RMR.Node.setStyles,\n\n\n  /*\n   * Position a popover relative to its target parent\n   *\n   * @param popover {HTMLElement} - the popover element\n   * @param target {HTMLElement} - the reference element for the popover\n   * @param data {Object} - object containing data for the popover\n   */\n  positionPopover = function positionPopover(popover, target, data) {\n    var targetRect = getRect(target),\n        popoverRect = getRect(popover),\n        arrow = popover.querySelector('.arrow');\n\n    var popoverXY = null,\n        arrowXY = null;\n\n    // set default location for popover\n    popoverXY = [targetRect.left + targetRect.width / 2 - popoverRect.width / 2, targetRect.top - popoverRect.height - 5 - data.margin];\n\n    arrowXY = [popoverXY[0], popoverXY[1]];\n    arrowXY[0] = popoverRect.width / 2 - 5;\n\n    var placeTopBottom = function placeTopBottom(popoverXY, arrowXY) {\n\n      popoverXY = [targetRect.left + targetRect.width / 2 - popoverRect.width / 2, targetRect.top - popoverRect.height - 5 - data.margin];\n\n      arrowXY = [popoverXY[0], popoverXY[1]];\n      arrowXY[0] = popoverRect.width / 2 - 5;\n\n      arrow.style.borderLeftColor = 'transparent';\n      arrow.style.borderRightColor = 'transparent';\n\n      if (popoverXY[1] - window.pageYOffset < 0) {\n        // clipped at top of browser?\n        arrowXY[1] = -10;\n        popoverXY[1] = targetRect.bottom + 5 + data.margin;\n\n        arrow.style.borderBottom = '5px solid ' + data.color;\n        popover.classList.add('bottom');\n      } else {\n        // top\n        arrowXY[1] = popoverRect.height;\n        arrow.style.borderTopColor = data.color;\n      }\n\n      if (popoverXY[0] < 0) {\n        // are we clipped on the left of the browser window ?\n        popoverXY[0] = 5;\n        arrowXY[0] = targetRect.left + targetRect.width / 2 - 10;\n      } else if (popoverXY[0] < targetRect.left) {\n        // is the popover further left than the target?\n        popoverXY[0] = targetRect.left - 5;\n        arrowXY[0] = targetRect.width / 2;\n      }\n\n      if (popoverXY[0] + popoverRect.width > window.innerWidth) {\n        // are we clipped on the right side of the browser window?\n        popoverXY[0] = window.innerWidth - popoverRect.width - 5;\n        arrowXY[0] = popoverRect.width - targetRect.width / 2;\n      }\n\n      return [popoverXY, arrowXY];\n    };\n\n    if (!data.position || data.position !== \"side\") {\n      // assume top of target\n\n      var ret = placeTopBottom(popoverXY, arrowXY);\n      popoverXY = ret[0];\n      arrowXY = ret[1];\n    } else {\n      // right-side of target\n      popoverXY[0] = targetRect.left + targetRect.width + 5 + data.margin;\n      popoverXY[1] = targetRect.top + targetRect.height / 2 - popoverRect.height / 2;\n\n      arrow.style.borderRightColor = data.color;\n\n      if (popoverXY[1] - window.pageYOffset < 0) {\n        popoverXY[1] = window.pageYOffset + data.margin;\n        arrowXY[1] = 5;\n      } else {\n        arrowXY[1] = popoverRect.height / 2 - 5;\n      }\n\n      arrowXY[0] = -10;\n\n      if (popoverXY[0] + popoverRect.width > window.innerWidth) {\n        // if clipped on right side, move to the left\n\n        popoverXY[0] = targetRect.left - popoverRect.width - 5 - data.margin;\n        popover.classList.add('left');\n        arrowXY[0] = popoverRect.width;\n\n        arrow.style.borderRightColor = 'transparent';\n        arrow.style.borderLeftColor = data.color;\n      }\n\n      if (popoverXY[0] < 0) {\n        // if also clipped on the left side, move to top/bottom\n        var _ret = placeTopBottom(popoverXY, arrowXY);\n        popoverXY = _ret[0];\n        arrowXY = _ret[1];\n      }\n    }\n\n    setStyles(popover, { left: parseInt(popoverXY[0], 10) + 'px', top: parseInt(popoverXY[1], 10) + 'px', backgroundColor: data.color });\n    setStyles(arrow, { left: parseInt(arrowXY[0], 10) + 'px', top: parseInt(arrowXY[1], 10) + 'px' });\n  },\n      timeouts = {},\n      // store window.setTimeout handles for popover hiding\n  pops = {}; // store popover HTMLElements keyed by their id attribute\n\n  /**\n   *\n   *\n   * @param {Object} config (optional) - control behaviour of Popover object\n   * @param {Object} defaults (optional) - default properties for individual popover elements\n   */\n  var Popover = function Popover(config, defaults) {\n    var self = this,\n        defaultConfig = {\n      attribute: ATTR,\n      debug: false,\n      root: document.body,\n      delay: { pop: 200, unpop: 300 },\n      factory: null\n    },\n        defaultProperties = {\n      color: COLOR,\n      margin: MARGIN,\n      cache: false,\n      'class': ''\n    },\n\n\n    /*\n     *\n     * @param e {MouseEvent} - mouseevent for the target element\n     * @param delay {Int}\n     */\n    _off = function _off(e, delay) {\n      var target = e.target,\n          f = function f() {\n        var id = target.getAttribute('id');\n        target.removeAttribute('aria-describedBy');\n        try {\n          var _data = getDataForNode(self, target),\n              pop = pops[_data.id];\n\n          if (pop) {\n            if (!self.debug) {\n\n              self.events.unpop(target, pop);\n              if (!_data.cache) {\n\n                delete timeouts[target.getAttribute('id')];\n                delete pops[_data.id];\n                pop.parentNode.removeChild(pop);\n              } else {\n                pop.classList.remove('pop');\n              }\n            }\n          }\n        } catch (e) {\n          if (self.debug) {\n            window.console.log('ERROR', e);\n          }\n        }\n      };\n\n      timeouts[target.getAttribute('id')] = window.setTimeout(f, arguments.length === 1 ? self.delay.unpop : delay);\n    },\n\n\n    /* Invoked when mouse hovers over the popover element\n     *\n     * @param e {MouseEvent}\n     */\n    over = function over(e) {\n      var n = e.target,\n          id = n.getAttribute('data-target');\n\n      n.addEventListener('mouseleave', function () {\n        _off({ target: document.getElementById(id) });\n      });\n\n      if (timeouts[id]) {\n        window.clearTimeout(timeouts[id]);\n        delete timeouts[id];\n      }\n    },\n\n\n    /* Invoked when the mouse enters the popover target element\n     *\n     * @param e {MouseEvent}\n     * @param delay {Int} - number of milliseconds to delay\n     */\n    _on = function _on(e, delay) {\n\n      if (!self.enabled) {\n        return;\n      }\n\n      var target = e.target,\n          data = getDataForNode(self, target);\n\n      data.class = (data.class ? data.class : '') + (data.position === \"side\" ? ' side' : ' top') + ' rmr-popover' + (data.persist ? ' persist' : '');\n\n      var n = document.querySelector('#' + data.id);\n      if (!n) {\n        // if the node exists, then the popover is visible & don't need to proceed\n        n = makeElement('div', { 'data-target': target.getAttribute('id'), role: 'tooltip', class: data.class, id: data.id });\n      }\n\n      var popper = function popper() {\n        if (n) {\n          n.classList.add('pop');\n          if (pops[n.getAttribute('id')]) {\n            // fire event listener\n            self.events.pop(target, n);\n          }\n        }\n      };\n\n      if (self.debug) {\n        window.console.log(data);\n      }\n\n      var reference = null;\n\n      if (data.node) {\n\n        reference = RMR.Node.get(data.node);\n        if (!reference) {\n          console.warn('Invalid reference node ' + data.node + ' for popover');\n        }\n        reference = reference.cloneNode(true);\n        reference.removeAttribute('aria-hidden');\n      }\n\n      // if a popover with this id already exists, don't display the one we just created\n\n      // if there's no content and no specific class, abort since it's an empty popover\n      if (!data.content && !data.class && !reference && !data.url) {\n        return;\n      }\n\n      var show = function show(content) {\n\n        if (!n.parentNode) {\n          n.innerHTML = '<b class=\"arrow\"></b><div class=\"bd\">' + content + '</div>';\n          window.document.body.appendChild(n);\n        }\n\n        if (reference) {\n          var bd = n.querySelector('div.bd');\n          bd.innerHTML = '';\n          bd.appendChild(reference);\n        }\n\n        target.setAttribute('aria-describedby', data.id);\n\n        positionPopover(n, target, data);\n\n        pops[data.id] = n;\n\n        window.setTimeout(function () {\n          popper();\n        }, delay ? delay : 0);\n\n        //\n        if (!data.persist) {\n          n.addEventListener('mouseenter', over);\n        }\n\n        //        n.setAttribute('data-shown', true);\n      };\n\n      if (data.url && !n.parentNode) {\n        RMR.XHR.request({ url: data.url }, function (xhr) {\n          if (xhr.status === 200) {\n            show(xhr.responseText);\n          } else {\n            if (self.debug) {\n              window.console.error('Popover XHR request failed', data.url);\n            }\n          }\n        });\n      } else {\n        //        window.document.body.appendChild(n);\n        show(data.content ? data.content : '');\n      }\n    };\n\n    config = merge(defaultConfig, config);\n\n    var nodes = null,\n        i = 0,\n        n = null,\n        node = null,\n        l = null,\n        data = null;\n\n    if (!config.hasOwnProperty('delay')) {\n      config.delay = defaultConfig.delay;\n    } else if (typeof config.delay === 'number') {\n      config.delay = { pop: config.delay, unpop: config.delay };\n    }\n\n    config = merge(defaultConfig, config);\n    this.defaults = merge(defaultProperties, defaults);\n\n    // two events are fired\n    this.events = {\n      pop: function pop() /* target, popover*/{},\n      unpop: function unpop() /* target, popover*/{}\n    };\n    this.enabled = true;\n    this.attribute = config.attribute;\n    this.delay = config.delay;\n    this.cache = config.cache;\n    this.factory = config.factory;\n    this.debug = config.debug;\n    this.listeners = {};\n\n    node = config.root ? config.root instanceof Element ? config.root : document.querySelector(config.root) : document.body;\n\n    if (!node) {\n      throw Error('Invalid Popover root [' + config.root + ']');\n    }\n\n    this.root = node;\n\n    if (this.factory) {\n      nodes = [this.root];\n    } else {\n      //\n      nodes = arr(node.querySelectorAll('[' + this.attribute + ']'));\n\n      // add root node if it has the data-popover attribute\n      if (node.hasAttribute(this.attribute)) {\n        nodes.push(node);\n      }\n    }\n    // init\n\n    for (i = 0; i < nodes.length; i++) {\n      n = nodes[i];\n\n      // ensure target has unique id\n      if (!n.getAttribute('id')) {\n        n.setAttribute('id', guid('popover-target-'));\n      }\n\n      // clear out title since we don't want the tooltip to obscure the popover\n      if (n.hasAttribute('title')) {\n        n.setAttribute('title', '');\n      }\n\n      l = {\n        on: function on(e) {\n          _on(e, self.delay.pop);\n        },\n        off: function off(e) {\n          _off(e, self.delay.unpop);\n        }\n      };\n      data = getDataForNode(this, n);\n\n      this.listeners[n.getAttribute('id')] = {\n        pop: l.on,\n        unpop: l.off\n      };\n\n      if (data.persist) {\n        // if this is a persistent popover, create it immediately\n        l.on({ target: n });\n        //        positionPopover(RMR.Node.get('#' + n.getAttribute('aria-describedby')), n, getDataForNode(self, n));\n      } else {\n        // otherwise attach the necessary listeners for mouse/touch interaction\n        if (data.events && data.events.pop) {\n          n.addEventListener(data.events.pop, l.on);\n        } else {\n          n.addEventListener('touchstart', l.on);\n          n.addEventListener('mouseenter', l.on);\n        }\n\n        if (data.events && data.events.unpop) {\n          n.addEventListener(data.events.unpop, l.off);\n        } else {\n          n.addEventListener('touchend', l.off);\n          n.addEventListener('mouseleave', l.off);\n        }\n      }\n    }\n\n    /*\n     * Re-position all persistent popovers on window resize\n     */\n    this.windowResizer = function () {\n      var target = null,\n          i = 0;\n\n      var persists = arr(document.querySelectorAll('.rmr-popover.persist'));\n\n      for (i = 0; i < persists.length; i++) {\n        target = document.getElementById(persists[i].getAttribute('data-target'));\n\n        positionPopover(persists[i], target, getDataForNode(this, target));\n      }\n    };\n\n    window.addEventListener('resize', function windowResize() {\n      self.windowResizer();\n    });\n\n    // position persistent popovers\n    window.setTimeout(function () {\n      self.windowResizer();\n    }, 0);\n\n    this.set = function (key, value) {\n      if (!this.defaults.hasOwnProperty(key)) {\n        throw new Error('Invalid key ', key);\n      }\n      this.defaults[key] = value;\n    };\n\n    this.destroy = function () {\n      var n = void 0,\n          data = void 0,\n          i = void 0;\n      for (i in this.listeners) {\n        if (!this.listeners.hasOwnProperty(i)) {\n          continue;\n        }\n\n        n = document.getElementById(i);\n        if (!n) {\n          continue;\n        }\n        data = getDataForNode(this, n);\n\n        if (data.events && data.events.pop) {\n          n.removeEventListener(data.events.pop, this.listeners[i].pop);\n        } else {\n          n.removeEventListener('mouseenter', this.listeners[i].pop);\n          n.removeEventListener('touchstart', this.listeners[i].pop);\n        }\n\n        if (data.events && data.events.unpop) {\n          n.removeEventListener(data.events.unpop, this.listeners[i].unpop);\n        } else {\n          n.removeEventListener('mouseleave', this.listeners[i].unpop);\n          n.removeEventListener('touchend', this.listeners[i].unpop);\n        }\n\n        // remove all popovers\n        _off({ target: n }, 0);\n      }\n\n      // remove resize listener\n      window.removeEventListener('resize', this.windowResizer);\n\n      return this;\n    };\n\n    if (this.debug) {\n      window.console.log(this.toString());\n    }\n\n    this.windowResizer();\n  };\n\n  /**\n   * Attach a listener to `pop`/`unpop` events\n   *\n   * @param {String} event - one of `pop` or `unpop`\n   * @param {Function} method - the method that will be invoked on the relevant event\n   * @return {Object} - instance for chaining\n   * @chainable\n   */\n  Popover.prototype.on = function (event, method) {\n    this.events[event] = method;\n    return this;\n  };\n\n  /**\n   * Return a string representation of the instance\n   *\n   * @return {String} description of object\n   */\n  Popover.prototype.toString = function () {\n    return 'Popover ' + JSON.stringify({ root: '' + this.root, enabled: this.enabled, delay: this.delay, debug: this.debug });\n  };\n\n  module.exports = Popover;\n})();\n\n//# sourceURL=webpack:///./src/popover.js?");

/***/ })

/******/ });